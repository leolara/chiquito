use crate::parser::ast::{expression::Expr, expression::Expression, statement::{Statement, TypedIdDecl}, Identifier, tl::TLDecl, debug_sym_factory::DebugSymRefFactory};
use crate::parser::build::*;
use num_bigint::BigInt;

grammar(dsym_factory: &DebugSymRefFactory);

match {
    r"\s*" => { }, // ignore spaces
    r"//[^\n\r]*[\n\r]*" => { }, // ignore `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // ignore `/* comments */`
    _,
}

// Top Level declaration
pub TLDecls: Vec<TLDecl<BigInt, Identifier>> = {
    <mut v: TLDecls> <d: ParseTLDecl> => {v.push(d); v},
    ParseTLDecl => vec![<>],
}

ParseTLDecl: TLDecl<BigInt, Identifier> = {
    ParseMachine,
}

ParseMachine: TLDecl<BigInt, Identifier> = {
    <l: @L> "machine" <id: Identifier> "(" <input_params: ParseParamsList> ")" <block: StatementsBlock> <r: @R> => TLDecl::MachineDecl{ dsym: dsym_factory.create(l,r), id, input_params, output_params: vec![], block},
    <l: @L> "machine" <id: Identifier> "(" <input_params: ParseParamsList> ")" "(" <output_params: ParseParamsList> ")" <block: StatementsBlock> <r: @R> => TLDecl::MachineDecl{ dsym: dsym_factory.create(l,r), id, input_params, output_params, block},
}

// Statements
StatementsBlock: Statement<BigInt, Identifier> = {
    <l: @L> "{" <v:Statements> "}" <r: @R> => Statement::Block(dsym_factory.create(l,r), v),
}

pub Statements: Vec<Statement<BigInt, Identifier>> = {
    <mut v: Statements> <e: ParseStatement> => {v.push(e); v},
    ParseStatement => vec![<>],
}

ParseStatement: Statement<BigInt, Identifier> = {
    <l: @L> <s: AssertEq> ";" <r: @R> => add_dsym(dsym_factory.create(l,r), s),
    <l: @L> <s: AssertNEq> ";" <r: @R> => add_dsym(dsym_factory.create(l,r), s),
    <l: @L> <s: Assert> ";" <r: @R> => add_dsym(dsym_factory.create(l,r), s),
    <l: @L> <a: SignalAssignmentAssert> ";" <r: @R> => add_dsym(dsym_factory.create(l,r), a),

    <l: @L> <a: SignalAssignment> ";" <r: @R> => add_dsym(dsym_factory.create(l,r), a),
    <l: @L> <a: WGAssignment> ";" <r: @R> => add_dsym(dsym_factory.create(l,r), a),

    <l: @L> <v: ParseSignalDecl> ";" <r: @R> => add_dsym(dsym_factory.create(l,r), v),
    <l: @L> <v: ParseWGVarDecl> ";" <r: @R> => add_dsym(dsym_factory.create(l,r), v),

    <l: @L> <t: ParseTransitionSimple> ";" <r: @R> => add_dsym(dsym_factory.create(l,r), t),

    <l: @L> <s: ParseIf> <r: @R> => add_dsym(dsym_factory.create(l,r), s),
    <l: @L> <s: ParseIfElse> <r: @R> => add_dsym(dsym_factory.create(l,r), s),

    <l: @L> <s: ParseState> <r: @R> => add_dsym(dsym_factory.create(l,r), s),
    <l: @L> <t: ParseTransition> <r: @R> => add_dsym(dsym_factory.create(l,r), t),
}

AssertEq: Statement<BigInt, Identifier> = {
    <l: @L> <lhs:Expression> "===" <rhs:Expression> <r: @R> => build_assert_eq(dsym_factory.create(l,r), lhs, rhs),
}

AssertNEq: Statement<BigInt, Identifier> = {
    <l: @L> <lhs:Expression> "!==" <rhs:Expression> <r: @R> => build_assert_neq(dsym_factory.create(l,r), lhs, rhs),
}

Assert: Statement<BigInt, Identifier> = {
    <l: @L> "assert" <e: ParseLogic> <r: @R> => Statement::Assert(dsym_factory.create(l,r), e),
}

// Basic statements
SignalAssignment: Statement<BigInt, Identifier> = {
    <l: @L> <ids: ParseIdsList> "<--" <es:ParseExpressionList> <r: @R> => Statement::SignalAssignment(dsym_factory.create(l,r), ids, es),
}

SignalAssignmentAssert: Statement<BigInt, Identifier> = {
    <l: @L> <ids: ParseIdsList> "<==" <es:ParseExpressionList> <r: @R> => Statement::SignalAssignmentAssert(dsym_factory.create(l,r), ids, es),
}

WGAssignment: Statement<BigInt, Identifier> = {
    <l: @L> <ids: ParseIdsList> "=" <es:ParseExpressionList> <r: @R> => Statement::WGAssignment(dsym_factory.create(l,r), ids, es),
}

ParseIf: Statement<BigInt, Identifier> = {
    <l: @L> "if" <cond: ParseLogic> <when_true: StatementsBlock> <r: @R> => Statement::IfThen(dsym_factory.create(l,r), Box::new(cond), Box::new(when_true)),
}

ParseIfElse: Statement<BigInt, Identifier> = {
    <l: @L> "if" <cond: ParseLogic> <when_true: StatementsBlock> "else" <when_false: StatementsBlock> <r: @R> => Statement::IfThenElse(dsym_factory.create(l,r), Box::new(cond), Box::new(when_true), Box::new(when_false)),
}

ParseState: Statement<BigInt, Identifier> = {
    <l: @L> "state" <id: Identifier> <block: StatementsBlock> <r: @R> => Statement::StateDecl(dsym_factory.create(l,r), id, Box::new(block))
}

ParseTransitionSimple: Statement<BigInt, Identifier> = {
    <l: @L> "->" <id: Identifier> <r: @R> => build_transition_simple(dsym_factory.create(l,r), id),
}

ParseTransition: Statement<BigInt, Identifier> = {
    <l: @L> "->" <id: Identifier> <block: StatementsBlock> <r: @R> => build_transition(dsym_factory.create(l,r), id, block),
}

ParseSignalDecl: Statement<BigInt, Identifier> = {
    <l: @L> "signal" <ids: ParseTypedIdList> <r: @R> => Statement::SignalDecl(dsym_factory.create(l,r), ids),
}

ParseWGVarDecl: Statement<BigInt, Identifier> = {
    <l: @L> "var" <ids: ParseTypedIdList> <r: @R> => Statement::WGVarDecl(dsym_factory.create(l,r), ids),
}

ParseSignalDeclSingle: Statement<BigInt, Identifier> = {
    <l: @L> "signal" <signal: ParseTypedId> <r: @R> => Statement::SignalDecl(dsym_factory.create(l,r), vec![signal]),
}

ParseWGVarDeclSingle: Statement<BigInt, Identifier> = {
    <l: @L> "var" <var: ParseTypedId> <r: @R> => Statement::WGVarDecl(dsym_factory.create(l,r), vec![var]),
}

// Expression
pub Expression = {
    ParseLogic,
}

// Logical expressions
ParseLogic: Expr = {
    ParseOr
}

ParseOr: Expr =  ParseLogichBinOp<"||", ParseAnd>;

ParseAnd: Expr =  ParseLogichBinOp<"&&", ParseEq>;

ParseEq: Expr = {
    <l: @L> <lhs: ParseArith> "==" <rhs: ParseArith> <r: @R> => build_bin_op("==", lhs, rhs, dsym_factory.create(l,r)),
    <l: @L>  <lhs: ParseArith> "!=" <rhs: ParseArith> <r: @R> => build_bin_op("!=", lhs, rhs, dsym_factory.create(l,r)),

    <l: @L>  <lhs: ParseArith> "<" <rhs: ParseArith> <r: @R> => build_bin_op("<", lhs, rhs, dsym_factory.create(l,r)),
    <l: @L>  <lhs: ParseArith> "<=" <rhs: ParseArith> <r: @R> => build_bin_op("<=", lhs, rhs, dsym_factory.create(l,r)),
    <l: @L>  <lhs: ParseArith> ">" <rhs: ParseArith> <r: @R> => build_bin_op(">", lhs, rhs, dsym_factory.create(l,r)),
    <l: @L>  <lhs: ParseArith> ">=" <rhs: ParseArith> <r: @R> => build_bin_op(">=", lhs, rhs, dsym_factory.create(l,r)),

    ParseBitOr
}

ParseBitOr: Expr =  ParseLogichBinOp<"|", ParseBitXor>;

ParseBitXor: Expr =  ParseLogichBinOp<"^", ParseBitAnd>;

ParseBitAnd: Expr =  ParseLogichBinOp<"&", ParseArith>;

// Arithmetical expressions
ParseArith: Expr = {
    ParseShift
}

ParseShift: Expr = {
    <l: @L> <lhs: ParseShift> "<<" <rhs: ParseSumSub> <r: @R> => build_bin_op("<<", lhs, rhs, dsym_factory.create(l,r)),
    <l: @L> <lhs: ParseShift> ">>" <rhs: ParseSumSub> <r: @R> => build_bin_op(">>", lhs, rhs, dsym_factory.create(l,r)),

    ParseSumSub
}

ParseSumSub: Expr = {
    <l: @L> <lhs: ParseSumSub> "-" <rhs: ParseMulDiv> <r: @R> => build_bin_op("-", lhs, rhs, dsym_factory.create(l,r)),
    <l: @L> <lhs: ParseSumSub> "+" <rhs: ParseMulDiv> <r: @R> => build_bin_op("+", lhs, rhs, dsym_factory.create(l,r)),

    ParseMulDiv
}

ParseMulDiv: Expr = {
    <l: @L> <lhs: ParseMulDiv> "%" <rhs: ParsePow> <r: @R> => build_bin_op("%", lhs, rhs, dsym_factory.create(l,r)),
    <l: @L> <lhs: ParseMulDiv> "/" <rhs: ParsePow> <r: @R> => build_bin_op("/", lhs, rhs, dsym_factory.create(l,r)),
    <l: @L> <lhs: ParseMulDiv> "\\" <rhs: ParsePow> <r: @R> => build_bin_op("\\", lhs, rhs, dsym_factory.create(l,r)),
    <l: @L> <lhs: ParseMulDiv> "*" <rhs: ParsePow> <r: @R> => build_bin_op("*", lhs, rhs, dsym_factory.create(l,r)),

    ParsePow
}

ParsePow: Expr = ParseArithBinOp<"**", ParsePrefix>;

ParsePrefix: Expr = {
    <l: @L> "-" <sub: ExpressionTerm> <r: @R> => build_unary_op("-", sub, dsym_factory.create(l,r)),
    <l: @L> "~" <sub: ExpressionTerm> <r: @R> => build_unary_op("~", sub, dsym_factory.create(l,r)),

    ExpressionTerm
}

ExpressionTerm: Expr = {
    <l: @L> <id: Identifier> <r: @R> => build_query(dsym_factory.create(l,r), id),
    <l: @L> <lit: FieldElement> <r: @R> => lit,
    <l: @L> "true" <r: @R> => Expression::True(dsym_factory.create(l,r)),
    <l: @L> "false" <r: @R> => Expression::False(dsym_factory.create(l,r)),
    <l: @L> "(" <e: Expression> ")" <r: @R> => e,
}

ParseLogichBinOp<Op, Next>: Expr = {
    <l: @L> <lhs: ParseArithBinOp<Op, Next>> <op: Op> <rhs: Next> <r: @R> => build_bin_op(op, lhs, rhs, dsym_factory.create(l,r)),

    Next
}

ParseArithBinOp<Op, Next>: Expr = {
    <l: @L> <lhs: ParseArithBinOp<Op, Next>> <op: Op> <rhs: Next> <r: @R> => build_bin_op(op, lhs, rhs, dsym_factory.create(l,r)),

    Next
}

ParseVar: Expr = {
    <l: @L> <id: Identifier> <r: @R> => build_query(dsym_factory.create(l,r), id),
}

// Lists

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

ParseParamsList = Comma<ParseParamDecl>;
ParseIdsList = Comma<Identifier>;
ParseTypedIdList = Comma<ParseTypedId>;
ParseExpressionList = Comma<Expression>;

// Other

ParseParamDecl: Statement<BigInt, Identifier> = {
    ParseSignalDeclSingle,
    ParseWGVarDeclSingle,
}

ParseTypedId: TypedIdDecl<Identifier> = {
    <id: Identifier> ":" <ty: Identifier> => TypedIdDecl { id, ty: Some(ty) },
    <id: Identifier> => TypedIdDecl { id, ty: None },
}

// Terminals

Identifier: Identifier = {
    r"[a-zA-Z_][a-zA-Z$_0-9@]*[\']?" => build_identifier(<>),
}

FieldElement: Expr = {
    <l: @L> <val: r"[0-9][0-9_]*"> <r: @R> => Expression::Const(dsym_factory.create(l,r), BigInt::parse_bytes(val.as_bytes(),10).expect("failed to parse base10")),
    <l: @L> <val: r"0x[0-9A-Fa-f][0-9A-Fa-f_]*"> <r: @R> => Expression::Const(dsym_factory.create(l,r), BigInt::parse_bytes(&val.as_bytes()[2..],16).expect("failed to parse base16")),
}
