use crate::parser::ast::{expression::Expression, statement::{Statement, TypedIdDecl}, Variable, tl::TLDecl, DebugSymRef};
use crate::parser::build::*;
use num_bigint::BigInt;

grammar;

match {
    r"\s*" => { }, // ignore spaces
    r"//[^\n\r]*[\n\r]*" => { }, // ignore `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // ignore `/* comments */`
    _,
}

// Top Level declaration
pub TLDecls: Vec<TLDecl<BigInt, Variable>> = {
    <mut v: TLDecls> <d: ParseTLDecl> => {v.push(d); v},
    ParseTLDecl => vec![<>],
}

ParseTLDecl: TLDecl<BigInt, Variable> = {
    ParseMachine,
}

ParseMachine: TLDecl<BigInt, Variable> = {
    "machine" <id: Identifier> "(" <params: ParseParamsList> ")" <block: StatementsBlock> => TLDecl::MachineDecl{ dsym: DebugSymRef::new(0,0), id, params, result: vec![], block},
    "machine" <id: Identifier> "(" <params: ParseParamsList> ")" "(" <result: ParseParamsList> ")" <block: StatementsBlock> => TLDecl::MachineDecl{ dsym: DebugSymRef::new(0,0), id, params, result, block},
}

// Statements
StatementsBlock: Statement<BigInt, Variable> = {
    "{" <v:Statements> "}" => Statement::Block(DebugSymRef::new(0,0), v),
}

pub Statements: Vec<Statement<BigInt, Variable>> = {
    <mut v: Statements> <e: ParseStatement> => {v.push(e); v},
    ParseStatement => vec![<>],
}

ParseStatement: Statement<BigInt, Variable> = {
    <s: AssertEq> ";" => s,
    <s: AssertNEq> ";" => s,
    <s: Assert> ";" => s,
    <a: AssignmentAssert> ";" => a,
    
    <a: Assignment> ";" => a,

    <v: ParseSignalDecl> ";" => v,
    <v: ParseVarDecl> ";" => v,

    <t: ParseTransitionSimple> ";" => t,

    ParseIf,
    ParseIfElse,

    ParseState,
    ParseTransition,
    
}

AssertEq: Statement<BigInt, Variable> = {
    <lhs:Expression> "===" <rhs:Expression> => build_assert_eq(DebugSymRef::new(0,0), lhs, rhs),
}

AssertNEq: Statement<BigInt, Variable> = {
    <lhs:Expression> "!==" <rhs:Expression> => build_assert_neq(DebugSymRef::new(0,0), lhs, rhs),
}

Assert: Statement<BigInt, Variable> = {
    "assert" <e: ParseLogic> => Statement::Assert(DebugSymRef::new(0,0), e),
}

// Basic statements
Assignment: Statement<BigInt, Variable> = {
    <ids: ParseIdsList> "<--" <es:ParseExpressionList> => Statement::Assignment(DebugSymRef::new(0,0), ids.into_iter().map(|id| Variable(id, 0)).collect(), es),
}

AssignmentAssert: Statement<BigInt, Variable> = {
    <ids: ParseIdsList> "<==" <es:ParseExpressionList> => Statement::AssignmentAssert(DebugSymRef::new(0,0), ids.into_iter().map(|id| Variable(id, 0)).collect(), es),
}

ParseIf: Statement<BigInt, Variable> = {
    "if" <cond: ParseLogic> <when_true: StatementsBlock> => Statement::IfThen(DebugSymRef::new(0,0), Box::new(cond), Box::new(when_true)),
}

ParseIfElse: Statement<BigInt, Variable> = {
    "if" <cond: ParseLogic> <when_true: StatementsBlock> "else" <when_false: StatementsBlock> => Statement::IfThenElse(DebugSymRef::new(0,0), Box::new(cond), Box::new(when_true), Box::new(when_false)),
}

ParseState: Statement<BigInt, Variable> = {
    "state" <id: Identifier> <block: StatementsBlock> => Statement::StateDecl(DebugSymRef::new(0,0), id, Box::new(block))
}

ParseTransitionSimple: Statement<BigInt, Variable> = {
    "->" <id: Identifier> => build_transition_simple(DebugSymRef::new(0,0), id),
}

ParseTransition: Statement<BigInt, Variable> = {
    "->" <id: Identifier> <block: StatementsBlock> => build_transition(DebugSymRef::new(0,0), id, block),
}

ParseSignalDecl: Statement<BigInt, Variable> = {
    "signal" <ids: ParseTypedIdList> => Statement::SignalDecl(DebugSymRef::new(0,0), ids),
}

ParseVarDecl: Statement<BigInt, Variable> = {
    "var" <ids: ParseTypedIdList> => Statement::VarDecl(DebugSymRef::new(0,0), ids),
}

ParseSignalDeclSingle: Statement<BigInt, Variable> = {
    "signal" <signal: ParseTypedId> => Statement::SignalDecl(DebugSymRef::new(0,0), vec![signal]),
}

ParseVarDeclSingle: Statement<BigInt, Variable> = {
    "var" <var: ParseTypedId> => Statement::VarDecl(DebugSymRef::new(0,0), vec![var]),
}

// Expression
pub Expression = {
    ParseLogic,
}

// Logical expressions
ParseLogic: Expression<BigInt, Variable> = {
    ParseOr
}

ParseOr: Expression<BigInt, Variable> =  ParseLogichBinOp<"||", ParseAnd>;

ParseAnd: Expression<BigInt, Variable> =  ParseLogichBinOp<"&&", ParseEq>;

ParseEq: Expression<BigInt, Variable> = {
    <lhs: ParseArith> "==" <rhs: ParseArith> => build_bin_op("==", lhs, rhs),
    <lhs: ParseArith> "!=" <rhs: ParseArith> => build_bin_op("!=", lhs, rhs),

    ParseArith
}

// Arithmetical expressions
ParseArith: Expression<BigInt, Variable> = {
    ParseSum
}

ParseSum: Expression<BigInt, Variable> = ParseArithBinOp<"+", ParseMul>;

ParseMul: Expression<BigInt, Variable> = ParseArithBinOp<"*", ParsePrefixMinus>;

ParsePrefixMinus: Expression<BigInt, Variable> = {
    "-" <sub: ExpressionTerm> => build_unary_op("-", sub),

    ExpressionTerm
}

ExpressionTerm: Expression<BigInt, Variable> = {
    ParseVar,
    FieldElement,
    "true" => Expression::True(DebugSymRef::new(0,0)),
    "false" => Expression::False(DebugSymRef::new(0,0)),
    "(" <Expression> ")",
}

ParseLogichBinOp<Op, Next>: Expression<BigInt, Variable> = {
    <lhs: ParseArithBinOp<Op, Next>> <op: Op> <rhs: Next> => build_bin_op(op, lhs, rhs),

    Next
}

ParseArithBinOp<Op, Next>: Expression<BigInt, Variable> = {
    <lhs: ParseArithBinOp<Op, Next>> <op: Op> <rhs: Next> => build_bin_op(op, lhs, rhs),

    Next
}

ParseVar: Expression<BigInt, Variable> = {
    <id: Identifier> => Expression::Query(DebugSymRef::new(0,0), Variable(id, 0)),
}

// Lists

Comma<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

ParseParamsList = Comma<ParseParamDecl>;
ParseIdsList = Comma<Identifier>;
ParseTypedIdList = Comma<ParseTypedId>;
ParseExpressionList = Comma<Expression>;


// Other

ParseParamDecl: Statement<BigInt, Variable> = {
    ParseSignalDeclSingle,
    ParseVarDeclSingle,
}

ParseTypedId: TypedIdDecl = {
    <id: Identifier> ":" <ty: Identifier> => TypedIdDecl { id, ty: Some(ty) },
    <id: Identifier> => TypedIdDecl { id, ty: None },
}

// Terminals

Identifier: String = {
    r"[a-zA-Z_][a-zA-Z$_0-9@]*'?" => String::from(<>),
}

FieldElement: Expression<BigInt, Variable> = {
    r"[0-9][0-9_]*" => Expression::Const(DebugSymRef::new(0,0), BigInt::parse_bytes(<>.as_bytes(),10).expect("failed to parse base10")),
    r"0x[0-9A-Fa-f][0-9A-Fa-f_]*" => Expression::Const(DebugSymRef::new(0,0), BigInt::parse_bytes(&(<>.as_bytes()[2..]),16).expect("failed to parse base16")),
}
